(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{296:function(n,a,e){"use strict";e.r(a);var l=e(13),J=Object(l.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul")]),n("p"),this._v(" "),n("p",[this._v("JVM面试题\n1、java中会存在内存泄漏吗，请简单描述。\n2、64 位 JVM 中，int 的长度是多数？\n3、Serial 与 Parallel GC 之间的不同之处？\n4、32 位和 64 位的 JVM，int 类型变量的长度是多数？\n5、Java 中 WeakReference 与 SoftReference 的区别？\n6、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用\n7、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？\n8、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？\n9、JRE、JDK、JVM 及 JIT 之间有什么不同？\n10、解释 Java 堆空间及 GC？\n11、JVM 内存区域\n12、程序计数器(线程私有)\n13、虚拟机栈(线程私有)\n14、本地方法区(线程私有)\n15、你能保证 GC 执行吗？\n16、怎么获取 Java 程序使用的内存？堆使用的百分比？\n17、Java 中堆和栈有什么区别？\n18、描述一下 JVM 加载 class 文件的原理机制\n19、GC 是什么？为什么要有 GC？\n20、堆（Heap-线程共享） -运行时数据区\n21、方法区/永久代（线程共享）\n22、JVM 运行时内存\n23、新生代\n24、老年代\n25、永久代\n26、JAVA8 与元数据\n27、引用计数法\n28、可达性分析\n29、标记清除算法（ Mark-Sweep）\n30、复制算法（copying）\n31、标记整理算法(Mark-Compact)\n32、分代收集算法\n33、新生代与复制算法\n34、老年代与标记复制算法\n35、JAVA 强引用\n36、JAVA软引用\n37、JAVA弱引用\n38、JAVA虚引用\n39、分代收集算法\n40、在新生代-复制算法\n41、在老年代-标记整理算法\n42、分区收集算法\n43、GC 垃圾收集器\n44、Serial 垃圾收集器（单线程、 复制算法）\n45、ParNew 垃圾收集器（Serial+多线程）\n46、Parallel Scavenge 收集器（多线程复制算法、高效）\n47、Serial Old 收集器（单线程标记整理算法 ）\n48、Parallel Old 收集器（多线程标记整理算法）\n49、CMS 收集器（多线程标记清除算法）\n50、G1 收集器\n51、JVM 类加载机制\n52、类加载器\n53、双亲委派\n54、OSGI（ 动态模型系统）\n55、动态改变构造\n56、模块化编程与热插拔\n57、JVM内存模型\n58、栈\n59、本地方法栈\n60、程序计数器\n61、堆\n62、方法区\n63、分代回收\n64、堆和栈的区别\n65、什么时候会触发FullGC\n66、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？\n67、对象分配规则\n68、描述一下JVM加载class文件的原理机制？\n69、Java对象创建过程\n70、简述Java的对象结构\n71、如何判断对象可以被回收\n72、JVM的永久代中会发生垃圾回收么\n73、垃圾收集算法\n74、调优命令有哪些？\n75、调优工具\n76、Minor GC与Full GC分别在什么时候发生？\n77、你知道哪些JVM性能调优")])])}),[],!1,null,null,null);a.default=J.exports}}]);