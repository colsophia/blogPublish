(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{327:function(a,t,r){"use strict";r.r(t);var e=r(13),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#java-并发编程"}},[a._v("Java 并发编程")]),t("ul",[t("li",[t("a",{attrs:{href:"#_1、在-java-中守护线程和本地线程区别"}},[a._v("1、在 java 中守护线程和本地线程区别？")])]),t("li",[t("a",{attrs:{href:"#_2、线程与进程的区别"}},[a._v("2、线程与进程的区别？")])]),t("li",[t("a",{attrs:{href:"#_3、什么是多线程中的上下文切换"}},[a._v("3、什么是多线程中的上下文切换？")])]),t("li",[t("a",{attrs:{href:"#_4、死锁与活锁的区别-死锁与饥饿的区别"}},[a._v("4、死锁与活锁的区别，死锁与饥饿的区别？")])]),t("li",[t("a",{attrs:{href:"#_5、java-中用到的线程调度算法是什么"}},[a._v("5、Java 中用到的线程调度算法是什么？")])]),t("li",[t("a",{attrs:{href:"#_6、什么是线程组-为什么在-java-中不推荐使用"}},[a._v("6、什么是线程组，为什么在 Java 中不推荐使用？")])]),t("li",[t("a",{attrs:{href:"#_7、为什么使用-executor-框架"}},[a._v("7、为什么使用 Executor 框架？")])]),t("li",[t("a",{attrs:{href:"#_8、在-java-中-executor-和-executors-的区别"}},[a._v("8、在 Java 中 Executor 和 Executors 的区别？")])]),t("li",[t("a",{attrs:{href:"#_9、如何在-windows-和-linux-上查找哪个线程使用的-cpu-时间最长"}},[a._v("9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？")])]),t("li",[t("a",{attrs:{href:"#_10、什么是原子操作-在-java-concurrency-api-中有哪些原子类-atomic-classes"}},[a._v("10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？")])]),t("li",[t("a",{attrs:{href:"#_11、java-concurrency-api-中的-lock-接口-lock-interface-是什么-对比同步它有什么优势"}},[a._v("11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？")])]),t("li",[t("a",{attrs:{href:"#_12、什么是-executors-框架"}},[a._v("12、什么是 Executors 框架？")])]),t("li",[t("a",{attrs:{href:"#_13、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型"}},[a._v("13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？")])]),t("li",[t("a",{attrs:{href:"#_14、什么是-callable-和-future"}},[a._v("14、什么是 Callable 和 Future?")])]),t("li",[t("a",{attrs:{href:"#_15、什么是-futuretask-使用-executorservice-启动任务。"}},[a._v("15、什么是 FutureTask?使用 ExecutorService 启动任务。")])]),t("li",[t("a",{attrs:{href:"#_16、什么是并发容器的实现"}},[a._v("16、什么是并发容器的实现？")])]),t("li",[t("a",{attrs:{href:"#_17、多线程同步和互斥有几种实现方法-都是什么"}},[a._v("17、多线程同步和互斥有几种实现方法，都是什么？")])]),t("li",[t("a",{attrs:{href:"#_18、什么是竞争条件-你怎样发现和解决竞争"}},[a._v("18、什么是竞争条件？你怎样发现和解决竞争？")])]),t("li",[t("a",{attrs:{href:"#_19、你将如何使用-thread-dump-你将如何分析-thread-dump"}},[a._v("19、你将如何使用 thread dump？你将如何分析 Thread dump？")])]),t("li",[t("a",{attrs:{href:"#_20、为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"}},[a._v("20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？")])]),t("li",[t("a",{attrs:{href:"#_21、java-中你怎样唤醒一个阻塞的线程"}},[a._v("21、Java 中你怎样唤醒一个阻塞的线程？")])]),t("li",[t("a",{attrs:{href:"#_22、在-java-中-cyclibarriar-和-countdownlatch-有什么区别"}},[a._v("22、在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？")])]),t("li",[t("a",{attrs:{href:"#_23、什么是不可变对象-它对写并发应用有什么帮助"}},[a._v("23、什么是不可变对象，它对写并发应用有什么帮助？")])]),t("li",[t("a",{attrs:{href:"#_24、什么是多线程中的上下文切换"}},[a._v("24、什么是多线程中的上下文切换？")])]),t("li",[t("a",{attrs:{href:"#_25、java-中用到的线程调度算法是什么"}},[a._v("25、Java 中用到的线程调度算法是什么？")])]),t("li",[t("a",{attrs:{href:"#_26、什么是线程组-为什么在-java-中不推荐使用"}},[a._v("26、什么是线程组，为什么在 Java 中不推荐使用？")])]),t("li",[t("a",{attrs:{href:"#_27、为什么使用-executor-框架比使用应用创建和管理线程好"}},[a._v("27、为什么使用 Executor 框架比使用应用创建和管理线程好？")])]),t("li",[t("a",{attrs:{href:"#_28、java-中有几种方法可以实现一个线程"}},[a._v("28、java 中有几种方法可以实现一个线程？")])]),t("li",[t("a",{attrs:{href:"#_29、如何停止一个正在运行的线程"}},[a._v("29、如何停止一个正在运行的线程？")])]),t("li",[t("a",{attrs:{href:"#_30、notify-和-notifyall-有什么区别"}},[a._v("30、notify()和 notifyAll()有什么区别？")])]),t("li",[t("a",{attrs:{href:"#_31、什么是-daemon-线程-它有什么意义"}},[a._v("31、什么是 Daemon 线程？它有什么意义？")])]),t("li",[t("a",{attrs:{href:"#_32、java-如何实现多线程之间的通讯和协作"}},[a._v("32、java 如何实现多线程之间的通讯和协作？")])]),t("li",[t("a",{attrs:{href:"#_33、什么是可重入锁-reentrantlock"}},[a._v("33、什么是可重入锁（ReentrantLock）？")])]),t("li",[t("a",{attrs:{href:"#_34、当一个线程进入某个对象的一个-synchronized-的实例方法后-其它线程是否可进入此对象的其它方法"}},[a._v("34、当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？")])]),t("li",[t("a",{attrs:{href:"#_35、乐观锁和悲观锁的理解及如何实现-有哪些实现方式"}},[a._v("35、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？")])]),t("li",[t("a",{attrs:{href:"#_36、synchronizedmap-和-concurrenthashmap-有什么区别"}},[a._v("36、SynchronizedMap 和 ConcurrentHashMap 有什么区别？")])]),t("li",[t("a",{attrs:{href:"#_37、copyonwritearraylist-可以用于什么应用场景"}},[a._v("37、CopyOnWriteArrayList 可以用于什么应用场景？")])]),t("li",[t("a",{attrs:{href:"#_38、什么叫线程安全-servlet-是线程安全吗"}},[a._v("38、什么叫线程安全？servlet 是线程安全吗?")])]),t("li",[t("a",{attrs:{href:"#_39、volatile-有什么用-能否用一句话说明下-volatile-的应用场景"}},[a._v("39、volatile 有什么用？能否用一句话说明下 volatile 的应用场景？")])]),t("li",[t("a",{attrs:{href:"#_40、为什么代码会重排序"}},[a._v("40、为什么代码会重排序？")])]),t("li",[t("a",{attrs:{href:"#_41、在-java-中-wait-和-sleep-方法的不同"}},[a._v("41、在 java 中 wait 和 sleep 方法的不同？")])]),t("li",[t("a",{attrs:{href:"#_42、用-java-实现阻塞队列"}},[a._v("42、用 Java 实现阻塞队列")])]),t("li",[t("a",{attrs:{href:"#_43、一个线程运行时发生异常会怎样"}},[a._v("43、一个线程运行时发生异常会怎样？")])]),t("li",[t("a",{attrs:{href:"#_44、如何在两个线程间共享数据"}},[a._v("44、如何在两个线程间共享数据？")])]),t("li",[t("a",{attrs:{href:"#_45、java-中-notify-和-notifyall-有什么区别"}},[a._v("45、Java 中 notify 和 notifyAll 有什么区别？")])]),t("li",[t("a",{attrs:{href:"#_46、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面"}},[a._v("46、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？")])]),t("li",[t("a",{attrs:{href:"#_47、什么是-threadlocal-变量"}},[a._v("47、什么是 ThreadLocal 变量？")])]),t("li",[t("a",{attrs:{href:"#_48、java-中-interrupted-和-isinterrupted-方法的区别"}},[a._v("48、Java 中 interrupted 和 isInterrupted 方法的区别？")])]),t("li",[t("a",{attrs:{href:"#_49、为什么-wait-和-notify-方法要在同步块中调用"}},[a._v("49、为什么 wait 和 notify 方法要在同步块中调用？")])]),t("li",[t("a",{attrs:{href:"#_50、为什么你应该在循环中检查等待条件"}},[a._v("50、为什么你应该在循环中检查等待条件?")])]),t("li",[t("a",{attrs:{href:"#_51、java-中的同步集合与并发集合有什么区别"}},[a._v("51、Java 中的同步集合与并发集合有什么区别？")])]),t("li",[t("a",{attrs:{href:"#_52、什么是线程池-为什么要使用它"}},[a._v("52、什么是线程池？ 为什么要使用它？")])]),t("li",[t("a",{attrs:{href:"#_53、怎么检测一个线程是否拥有锁"}},[a._v("53、怎么检测一个线程是否拥有锁？")])]),t("li",[t("a",{attrs:{href:"#_54、你如何在-java-中获取线程堆栈"}},[a._v("54、你如何在 Java 中获取线程堆栈？")])]),t("li",[t("a",{attrs:{href:"#_56、thread-类中的-yield-方法有什么作用"}},[a._v("56、Thread 类中的 yield 方法有什么作用？")])]),t("li",[t("a",{attrs:{href:"#_57、java-中-concurrenthashmap-的并发度是什么"}},[a._v("57、Java 中 ConcurrentHashMap 的并发度是什么？")])]),t("li",[t("a",{attrs:{href:"#_58、java-中-semaphore-是什么"}},[a._v("58、Java 中 Semaphore 是什么？")])]),t("li",[t("a",{attrs:{href:"#_59、java-线程池中-submit-和-execute-方法有什么区别"}},[a._v("59、Java 线程池中 submit() 和 execute()方法有什么区别？")])]),t("li",[t("a",{attrs:{href:"#_60、什么是阻塞式方法"}},[a._v("60、什么是阻塞式方法？")])]),t("li",[t("a",{attrs:{href:"#_61、java-中的-readwritelock-是什么"}},[a._v("61、Java 中的 ReadWriteLock 是什么？")])]),t("li",[t("a",{attrs:{href:"#_62、volatile-变量和-atomic-变量有什么不同"}},[a._v("62、volatile 变量和 atomic 变量有什么不同？")])]),t("li",[t("a",{attrs:{href:"#_63、可以直接调用-thread-类的-run-方法么"}},[a._v("63、可以直接调用 Thread 类的 run ()方法么？")])]),t("li",[t("a",{attrs:{href:"#_64、如何让正在运行的线程暂停一段时间"}},[a._v("64、如何让正在运行的线程暂停一段时间？")])]),t("li",[t("a",{attrs:{href:"#_65、你对线程优先级的理解是什么"}},[a._v("65、你对线程优先级的理解是什么？")])]),t("li",[t("a",{attrs:{href:"#_66-、-什-么-是-线-程-调-度-器-thread-scheduler-和-时-间-分-片-timeslicing"}},[a._v("66 、 什 么 是 线 程 调 度 器 (Thread Scheduler) 和 时 间 分 片 (TimeSlicing )？")])]),t("li",[t("a",{attrs:{href:"#_67、你如何确保-main-方法所在的线程是-java-程序最后结束的线程"}},[a._v("67、你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？")])]),t("li",[t("a",{attrs:{href:"#_68、线程之间是如何通信的"}},[a._v("68、线程之间是如何通信的？")])]),t("li",[t("a",{attrs:{href:"#_69、为什么线程通信的方法-wait-notify-和-notifyall-被定义在object-类里"}},[a._v("69、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在Object 类里？")])]),t("li",[t("a",{attrs:{href:"#_70、为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用"}},[a._v("70、为什么 wait(), notify()和 notifyAll ()必须在同步方法或者同步块中被调用？")])]),t("li",[t("a",{attrs:{href:"#_71、为什么-thread-类的-sleep-和-yield-方法是静态的"}},[a._v("71、为什么 Thread 类的 sleep()和 yield ()方法是静态的？")])]),t("li",[t("a",{attrs:{href:"#_72、如何确保线程安全"}},[a._v("72、如何确保线程安全？")])]),t("li",[t("a",{attrs:{href:"#_73、同步方法和同步块-哪个是更好的选择"}},[a._v("73、同步方法和同步块，哪个是更好的选择？")])]),t("li",[t("a",{attrs:{href:"#_74、如何创建守护线程"}},[a._v("74、如何创建守护线程？")])]),t("li",[t("a",{attrs:{href:"#_75、什么是-java-timer-类-如何创建一个有特定时间间隔的任务"}},[a._v("75、什么是 Java Timer 类？如何创建一个有特定时间间隔的任务？")])])])])])]),t("p"),a._v(" "),t("h2",{attrs:{id:"java-并发编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-并发编程"}},[a._v("#")]),a._v(" Java 并发编程")]),a._v(" "),t("h3",{attrs:{id:"_1、在-java-中守护线程和本地线程区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、在-java-中守护线程和本地线程区别"}},[a._v("#")]),a._v(" 1、在 java 中守护线程和本地线程区别？")]),a._v(" "),t("h3",{attrs:{id:"_2、线程与进程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、线程与进程的区别"}},[a._v("#")]),a._v(" 2、线程与进程的区别？")]),a._v(" "),t("h3",{attrs:{id:"_3、什么是多线程中的上下文切换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是多线程中的上下文切换"}},[a._v("#")]),a._v(" 3、什么是多线程中的上下文切换？")]),a._v(" "),t("h3",{attrs:{id:"_4、死锁与活锁的区别-死锁与饥饿的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、死锁与活锁的区别-死锁与饥饿的区别"}},[a._v("#")]),a._v(" 4、死锁与活锁的区别，死锁与饥饿的区别？")]),a._v(" "),t("h3",{attrs:{id:"_5、java-中用到的线程调度算法是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、java-中用到的线程调度算法是什么"}},[a._v("#")]),a._v(" 5、Java 中用到的线程调度算法是什么？")]),a._v(" "),t("h3",{attrs:{id:"_6、什么是线程组-为什么在-java-中不推荐使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、什么是线程组-为什么在-java-中不推荐使用"}},[a._v("#")]),a._v(" 6、什么是线程组，为什么在 Java 中不推荐使用？")]),a._v(" "),t("h3",{attrs:{id:"_7、为什么使用-executor-框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、为什么使用-executor-框架"}},[a._v("#")]),a._v(" 7、为什么使用 Executor 框架？")]),a._v(" "),t("h3",{attrs:{id:"_8、在-java-中-executor-和-executors-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、在-java-中-executor-和-executors-的区别"}},[a._v("#")]),a._v(" 8、在 Java 中 Executor 和 Executors 的区别？")]),a._v(" "),t("h3",{attrs:{id:"_9、如何在-windows-和-linux-上查找哪个线程使用的-cpu-时间最长"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9、如何在-windows-和-linux-上查找哪个线程使用的-cpu-时间最长"}},[a._v("#")]),a._v(" 9、如何在 Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？")]),a._v(" "),t("h3",{attrs:{id:"_10、什么是原子操作-在-java-concurrency-api-中有哪些原子类-atomic-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10、什么是原子操作-在-java-concurrency-api-中有哪些原子类-atomic-classes"}},[a._v("#")]),a._v(" 10、什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？")]),a._v(" "),t("h3",{attrs:{id:"_11、java-concurrency-api-中的-lock-接口-lock-interface-是什么-对比同步它有什么优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11、java-concurrency-api-中的-lock-接口-lock-interface-是什么-对比同步它有什么优势"}},[a._v("#")]),a._v(" 11、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？")]),a._v(" "),t("h3",{attrs:{id:"_12、什么是-executors-框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12、什么是-executors-框架"}},[a._v("#")]),a._v(" 12、什么是 Executors 框架？")]),a._v(" "),t("h3",{attrs:{id:"_13、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13、什么是阻塞队列-阻塞队列的实现原理是什么-如何使用阻塞队列来实现生产者-消费者模型"}},[a._v("#")]),a._v(" 13、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？")]),a._v(" "),t("h3",{attrs:{id:"_14、什么是-callable-和-future"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14、什么是-callable-和-future"}},[a._v("#")]),a._v(" 14、什么是 Callable 和 Future?")]),a._v(" "),t("h3",{attrs:{id:"_15、什么是-futuretask-使用-executorservice-启动任务。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15、什么是-futuretask-使用-executorservice-启动任务。"}},[a._v("#")]),a._v(" 15、什么是 FutureTask?使用 ExecutorService 启动任务。")]),a._v(" "),t("h3",{attrs:{id:"_16、什么是并发容器的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16、什么是并发容器的实现"}},[a._v("#")]),a._v(" 16、什么是并发容器的实现？")]),a._v(" "),t("h3",{attrs:{id:"_17、多线程同步和互斥有几种实现方法-都是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17、多线程同步和互斥有几种实现方法-都是什么"}},[a._v("#")]),a._v(" 17、多线程同步和互斥有几种实现方法，都是什么？")]),a._v(" "),t("h3",{attrs:{id:"_18、什么是竞争条件-你怎样发现和解决竞争"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18、什么是竞争条件-你怎样发现和解决竞争"}},[a._v("#")]),a._v(" 18、什么是竞争条件？你怎样发现和解决竞争？")]),a._v(" "),t("h3",{attrs:{id:"_19、你将如何使用-thread-dump-你将如何分析-thread-dump"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19、你将如何使用-thread-dump-你将如何分析-thread-dump"}},[a._v("#")]),a._v(" 19、你将如何使用 thread dump？你将如何分析 Thread dump？")]),a._v(" "),t("h3",{attrs:{id:"_20、为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20、为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用-run-方法"}},[a._v("#")]),a._v(" 20、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？")]),a._v(" "),t("h3",{attrs:{id:"_21、java-中你怎样唤醒一个阻塞的线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21、java-中你怎样唤醒一个阻塞的线程"}},[a._v("#")]),a._v(" 21、Java 中你怎样唤醒一个阻塞的线程？")]),a._v(" "),t("h3",{attrs:{id:"_22、在-java-中-cyclibarriar-和-countdownlatch-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22、在-java-中-cyclibarriar-和-countdownlatch-有什么区别"}},[a._v("#")]),a._v(" 22、在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"_23、什么是不可变对象-它对写并发应用有什么帮助"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23、什么是不可变对象-它对写并发应用有什么帮助"}},[a._v("#")]),a._v(" 23、什么是不可变对象，它对写并发应用有什么帮助？")]),a._v(" "),t("h3",{attrs:{id:"_24、什么是多线程中的上下文切换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24、什么是多线程中的上下文切换"}},[a._v("#")]),a._v(" 24、什么是多线程中的上下文切换？")]),a._v(" "),t("h3",{attrs:{id:"_25、java-中用到的线程调度算法是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25、java-中用到的线程调度算法是什么"}},[a._v("#")]),a._v(" 25、Java 中用到的线程调度算法是什么？")]),a._v(" "),t("h3",{attrs:{id:"_26、什么是线程组-为什么在-java-中不推荐使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26、什么是线程组-为什么在-java-中不推荐使用"}},[a._v("#")]),a._v(" 26、什么是线程组，为什么在 Java 中不推荐使用？")]),a._v(" "),t("h3",{attrs:{id:"_27、为什么使用-executor-框架比使用应用创建和管理线程好"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27、为什么使用-executor-框架比使用应用创建和管理线程好"}},[a._v("#")]),a._v(" 27、为什么使用 Executor 框架比使用应用创建和管理线程好？")]),a._v(" "),t("h3",{attrs:{id:"_28、java-中有几种方法可以实现一个线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28、java-中有几种方法可以实现一个线程"}},[a._v("#")]),a._v(" 28、java 中有几种方法可以实现一个线程？")]),a._v(" "),t("h3",{attrs:{id:"_29、如何停止一个正在运行的线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_29、如何停止一个正在运行的线程"}},[a._v("#")]),a._v(" 29、如何停止一个正在运行的线程？")]),a._v(" "),t("h3",{attrs:{id:"_30、notify-和-notifyall-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_30、notify-和-notifyall-有什么区别"}},[a._v("#")]),a._v(" 30、notify()和 notifyAll()有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"_31、什么是-daemon-线程-它有什么意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_31、什么是-daemon-线程-它有什么意义"}},[a._v("#")]),a._v(" 31、什么是 Daemon 线程？它有什么意义？")]),a._v(" "),t("h3",{attrs:{id:"_32、java-如何实现多线程之间的通讯和协作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_32、java-如何实现多线程之间的通讯和协作"}},[a._v("#")]),a._v(" 32、java 如何实现多线程之间的通讯和协作？")]),a._v(" "),t("h3",{attrs:{id:"_33、什么是可重入锁-reentrantlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_33、什么是可重入锁-reentrantlock"}},[a._v("#")]),a._v(" 33、什么是可重入锁（ReentrantLock）？")]),a._v(" "),t("h3",{attrs:{id:"_34、当一个线程进入某个对象的一个-synchronized-的实例方法后-其它线程是否可进入此对象的其它方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_34、当一个线程进入某个对象的一个-synchronized-的实例方法后-其它线程是否可进入此对象的其它方法"}},[a._v("#")]),a._v(" 34、当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？")]),a._v(" "),t("h3",{attrs:{id:"_35、乐观锁和悲观锁的理解及如何实现-有哪些实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_35、乐观锁和悲观锁的理解及如何实现-有哪些实现方式"}},[a._v("#")]),a._v(" 35、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？")]),a._v(" "),t("h3",{attrs:{id:"_36、synchronizedmap-和-concurrenthashmap-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_36、synchronizedmap-和-concurrenthashmap-有什么区别"}},[a._v("#")]),a._v(" 36、SynchronizedMap 和 ConcurrentHashMap 有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"_37、copyonwritearraylist-可以用于什么应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_37、copyonwritearraylist-可以用于什么应用场景"}},[a._v("#")]),a._v(" 37、CopyOnWriteArrayList 可以用于什么应用场景？")]),a._v(" "),t("h3",{attrs:{id:"_38、什么叫线程安全-servlet-是线程安全吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_38、什么叫线程安全-servlet-是线程安全吗"}},[a._v("#")]),a._v(" 38、什么叫线程安全？servlet 是线程安全吗?")]),a._v(" "),t("h3",{attrs:{id:"_39、volatile-有什么用-能否用一句话说明下-volatile-的应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_39、volatile-有什么用-能否用一句话说明下-volatile-的应用场景"}},[a._v("#")]),a._v(" 39、volatile 有什么用？能否用一句话说明下 volatile 的应用场景？")]),a._v(" "),t("h3",{attrs:{id:"_40、为什么代码会重排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_40、为什么代码会重排序"}},[a._v("#")]),a._v(" 40、为什么代码会重排序？")]),a._v(" "),t("h3",{attrs:{id:"_41、在-java-中-wait-和-sleep-方法的不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_41、在-java-中-wait-和-sleep-方法的不同"}},[a._v("#")]),a._v(" 41、在 java 中 wait 和 sleep 方法的不同？")]),a._v(" "),t("h3",{attrs:{id:"_42、用-java-实现阻塞队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_42、用-java-实现阻塞队列"}},[a._v("#")]),a._v(" 42、用 Java 实现阻塞队列")]),a._v(" "),t("h3",{attrs:{id:"_43、一个线程运行时发生异常会怎样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_43、一个线程运行时发生异常会怎样"}},[a._v("#")]),a._v(" 43、一个线程运行时发生异常会怎样？")]),a._v(" "),t("h3",{attrs:{id:"_44、如何在两个线程间共享数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_44、如何在两个线程间共享数据"}},[a._v("#")]),a._v(" 44、如何在两个线程间共享数据？")]),a._v(" "),t("h3",{attrs:{id:"_45、java-中-notify-和-notifyall-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_45、java-中-notify-和-notifyall-有什么区别"}},[a._v("#")]),a._v(" 45、Java 中 notify 和 notifyAll 有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"_46、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_46、为什么-wait-notify-和-notifyall-这些方法不在-thread-类里面"}},[a._v("#")]),a._v(" 46、为什么 wait, notify 和 notifyAll 这些方法不在 thread 类里面？")]),a._v(" "),t("h3",{attrs:{id:"_47、什么是-threadlocal-变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_47、什么是-threadlocal-变量"}},[a._v("#")]),a._v(" 47、什么是 ThreadLocal 变量？")]),a._v(" "),t("h3",{attrs:{id:"_48、java-中-interrupted-和-isinterrupted-方法的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_48、java-中-interrupted-和-isinterrupted-方法的区别"}},[a._v("#")]),a._v(" 48、Java 中 interrupted 和 isInterrupted 方法的区别？")]),a._v(" "),t("h3",{attrs:{id:"_49、为什么-wait-和-notify-方法要在同步块中调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_49、为什么-wait-和-notify-方法要在同步块中调用"}},[a._v("#")]),a._v(" 49、为什么 wait 和 notify 方法要在同步块中调用？")]),a._v(" "),t("h3",{attrs:{id:"_50、为什么你应该在循环中检查等待条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_50、为什么你应该在循环中检查等待条件"}},[a._v("#")]),a._v(" 50、为什么你应该在循环中检查等待条件?")]),a._v(" "),t("h3",{attrs:{id:"_51、java-中的同步集合与并发集合有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_51、java-中的同步集合与并发集合有什么区别"}},[a._v("#")]),a._v(" 51、Java 中的同步集合与并发集合有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"_52、什么是线程池-为什么要使用它"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_52、什么是线程池-为什么要使用它"}},[a._v("#")]),a._v(" 52、什么是线程池？ 为什么要使用它？")]),a._v(" "),t("h3",{attrs:{id:"_53、怎么检测一个线程是否拥有锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_53、怎么检测一个线程是否拥有锁"}},[a._v("#")]),a._v(" 53、怎么检测一个线程是否拥有锁？")]),a._v(" "),t("h3",{attrs:{id:"_54、你如何在-java-中获取线程堆栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_54、你如何在-java-中获取线程堆栈"}},[a._v("#")]),a._v(" 54、你如何在 Java 中获取线程堆栈？")]),a._v(" "),t("h3",{attrs:{id:"_56、thread-类中的-yield-方法有什么作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_56、thread-类中的-yield-方法有什么作用"}},[a._v("#")]),a._v(" 56、Thread 类中的 yield 方法有什么作用？")]),a._v(" "),t("h3",{attrs:{id:"_57、java-中-concurrenthashmap-的并发度是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_57、java-中-concurrenthashmap-的并发度是什么"}},[a._v("#")]),a._v(" 57、Java 中 ConcurrentHashMap 的并发度是什么？")]),a._v(" "),t("h3",{attrs:{id:"_58、java-中-semaphore-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_58、java-中-semaphore-是什么"}},[a._v("#")]),a._v(" 58、Java 中 Semaphore 是什么？")]),a._v(" "),t("h3",{attrs:{id:"_59、java-线程池中-submit-和-execute-方法有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_59、java-线程池中-submit-和-execute-方法有什么区别"}},[a._v("#")]),a._v(" 59、Java 线程池中 submit() 和 execute()方法有什么区别？")]),a._v(" "),t("h3",{attrs:{id:"_60、什么是阻塞式方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_60、什么是阻塞式方法"}},[a._v("#")]),a._v(" 60、什么是阻塞式方法？")]),a._v(" "),t("h3",{attrs:{id:"_61、java-中的-readwritelock-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_61、java-中的-readwritelock-是什么"}},[a._v("#")]),a._v(" 61、Java 中的 ReadWriteLock 是什么？")]),a._v(" "),t("h3",{attrs:{id:"_62、volatile-变量和-atomic-变量有什么不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_62、volatile-变量和-atomic-变量有什么不同"}},[a._v("#")]),a._v(" 62、volatile 变量和 atomic 变量有什么不同？")]),a._v(" "),t("h3",{attrs:{id:"_63、可以直接调用-thread-类的-run-方法么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_63、可以直接调用-thread-类的-run-方法么"}},[a._v("#")]),a._v(" 63、可以直接调用 Thread 类的 run ()方法么？")]),a._v(" "),t("h3",{attrs:{id:"_64、如何让正在运行的线程暂停一段时间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_64、如何让正在运行的线程暂停一段时间"}},[a._v("#")]),a._v(" 64、如何让正在运行的线程暂停一段时间？")]),a._v(" "),t("h3",{attrs:{id:"_65、你对线程优先级的理解是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_65、你对线程优先级的理解是什么"}},[a._v("#")]),a._v(" 65、你对线程优先级的理解是什么？")]),a._v(" "),t("h3",{attrs:{id:"_66-、-什-么-是-线-程-调-度-器-thread-scheduler-和-时-间-分-片-timeslicing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_66-、-什-么-是-线-程-调-度-器-thread-scheduler-和-时-间-分-片-timeslicing"}},[a._v("#")]),a._v(" 66 、 什 么 是 线 程 调 度 器 (Thread Scheduler) 和 时 间 分 片 (TimeSlicing )？")]),a._v(" "),t("h3",{attrs:{id:"_67、你如何确保-main-方法所在的线程是-java-程序最后结束的线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_67、你如何确保-main-方法所在的线程是-java-程序最后结束的线程"}},[a._v("#")]),a._v(" 67、你如何确保 main()方法所在的线程是 Java 程序最后结束的线程？")]),a._v(" "),t("h3",{attrs:{id:"_68、线程之间是如何通信的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_68、线程之间是如何通信的"}},[a._v("#")]),a._v(" 68、线程之间是如何通信的？")]),a._v(" "),t("h3",{attrs:{id:"_69、为什么线程通信的方法-wait-notify-和-notifyall-被定义在object-类里"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_69、为什么线程通信的方法-wait-notify-和-notifyall-被定义在object-类里"}},[a._v("#")]),a._v(" 69、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在Object 类里？")]),a._v(" "),t("h3",{attrs:{id:"_70、为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_70、为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用"}},[a._v("#")]),a._v(" 70、为什么 wait(), notify()和 notifyAll ()必须在同步方法或者同步块中被调用？")]),a._v(" "),t("h3",{attrs:{id:"_71、为什么-thread-类的-sleep-和-yield-方法是静态的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_71、为什么-thread-类的-sleep-和-yield-方法是静态的"}},[a._v("#")]),a._v(" 71、为什么 Thread 类的 sleep()和 yield ()方法是静态的？")]),a._v(" "),t("h3",{attrs:{id:"_72、如何确保线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_72、如何确保线程安全"}},[a._v("#")]),a._v(" 72、如何确保线程安全？")]),a._v(" "),t("h3",{attrs:{id:"_73、同步方法和同步块-哪个是更好的选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_73、同步方法和同步块-哪个是更好的选择"}},[a._v("#")]),a._v(" 73、同步方法和同步块，哪个是更好的选择？")]),a._v(" "),t("h3",{attrs:{id:"_74、如何创建守护线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_74、如何创建守护线程"}},[a._v("#")]),a._v(" 74、如何创建守护线程？")]),a._v(" "),t("h3",{attrs:{id:"_75、什么是-java-timer-类-如何创建一个有特定时间间隔的任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_75、什么是-java-timer-类-如何创建一个有特定时间间隔的任务"}},[a._v("#")]),a._v(" 75、什么是 Java Timer 类？如何创建一个有特定时间间隔的任务？")])])}),[],!1,null,null,null);t.default=s.exports}}]);